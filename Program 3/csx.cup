/** csx CUP Specification
 *  @author Doug Fultz
 *  @author Sujay Kallamadi
 */

import java_cup.runtime.*;

parser code {:
    public void syntax_error(Symbol cur_token){
        report_error("CSX syntax error at line "+String.valueOf(((CSXToken)cur_token.value).linenum),null);
    }
:};

/* Preliminaries to set up and use the scanner.  */
init with {:              :};
scan with {: return Scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
//Assignment
terminal CSXToken               ASG;
//Comparision
terminal CSXToken               EQ, NOTEQ, GEQ, GT, LEQ, LT;
//Boolean
terminal CSXToken               CAND, COR, NOT;
//Math
terminal CSXToken               MINUS, PLUS, SLASH, TIMES;
//Inrement/Decrement
terminal CSXToken               DEC, INC;
//Braces
terminal CSXToken               LBRACE, RBRACE;
//Brackets
terminal CSXToken               LBRACKET, RBRACKET;
//Parenthesis
terminal CSXToken               LPAREN, RPAREN;
//Reserved Words
terminal CSXToken               rw_BOOL, rw_BREAK, rw_CHAR, rw_CLASS, rw_CONST, rw_CONTINUE, rw_ELSE, rw_FALSE, rw_FLOAT, rw_IF, rw_INT, rw_PRINT, rw_READ, rw_RETURN, rw_TRUE, rw_VOID, rw_WHILE;
//Miscellaneous Symbols
terminal CSXToken               COLON, COMMA, SEMI;
//Error
//terminal CSXToken               error;
//End of file
//terminal CSXToken               EOF;
//Character Literal
terminal CSXCharLitToken        CHARLIT;
//Identifier
terminal CSXIdentifierToken     IDENTIFIER;
//Integer Literal
terminal CSXIntLitToken         INTLIT;
//Float Literal
terminal CSXFloatLitToken       FLOATLIT;
//String Literal
terminal CSXStringLitToken      STRLIT;

/* Non terminals */
non terminal csxNode            Program;
non terminal memberDeclsNode    Memberdecls;
non terminal fieldDeclsNode     Fielddecls;
non terminal methodDecelsNode   Methoddecls;
non terminal optionalSimiNode   OptionalSemi;
non terminal methodDecelsNode   Methoddecl;
non terminal argDeclsNode       Argdecls;
non terminal argDeclNode        Argdecl;
non terminal fieldDeclNode      Fielddecl;
non terminal stmtsNode          Stmts;
non terminal stmtNode           Stmt;
non terminal typeNode           Type;
non terminal argsNode           Args;
non terminal readListNode       Readlist;
non terminal printListNode      Printlist;
non terminal exprNode           Expr;
non terminal termNode           Term;
non terminal factorNode         Factor;
non terminal priNode            Pri;
non terminal unaryNode          Unary;
non terminal unitNode           Unit;
non terminal nameNode           name;

/* Precedences */

/* The grammar */
start with prog;

prog        ::= LBRACE:l stmts:s RBRACE
                {: RESULT=new csxLiteNode(s, l.linenum,l.colnum); :}
            ;

stmts       ::= stmt:s1  stmts:s2
                {: RESULT=new stmtsNode(s1,s2,s1.linenum,s1.colnum); :}
            |
                {: RESULT= stmtsNode.NULL; :}
            ;

stmt		::= ident:id ASG exp:e SEMI
			 {: RESULT=
			new asgNode(id,e,id.linenum,id.colnum);
			 :}	

		| rw_IF:i LPAREN exp:e RPAREN  stmt:s
			 {:
			 RESULT=new ifThenNode(e,s,stmtNode.NULL,
						i.linenum,i.colnum); :}	
		;
exp		::= exp:leftval PLUS:op ident:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.PLUS,rightval,op.linenum,op.colnum); :}	
		| exp:leftval MINUS:op ident:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.MINUS,rightval,op.linenum,op.colnum); :}	
		| ident:i		
			 {: RESULT = i; :}
		;
ident		::= IDENTIFIER:i
			 {: RESULT = new nameNode(
					  new identNode(i.identifierText,
						 i.linenum,i.colnum),
					  exprNode.NULL,
					  i.linenum,i.colnum); :}	
		;
