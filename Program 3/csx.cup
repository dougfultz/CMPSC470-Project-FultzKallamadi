/** csx CUP Specification
 *  @author Doug Fultz
 *  @author Sujay Kallamadi
 */

import java_cup.runtime.*;

parser code {:
    public void syntax_error(Symbol cur_token){
        report_error("CSX syntax error at line "+String.valueOf(((CSXToken)cur_token.value).linenum),null);
    }
:};

/* Preliminaries to set up and use the scanner.  */
init with {:              :};
scan with {: return Scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
//Assignment
terminal CSXToken               ASG;
//Comparision
terminal CSXToken               EQ, NOTEQ, GEQ, GT, LEQ, LT;
//Boolean
terminal CSXToken               CAND, COR, NOT;
//Math
terminal CSXToken               MINUS, PLUS, SLASH, TIMES;
//Inrement/Decrement
//terminal CSXToken               DEC, INC;
//Braces
terminal CSXToken               LBRACE, RBRACE;
//Brackets
terminal CSXToken               LBRACKET, RBRACKET;
//Parenthesis
terminal CSXToken               LPAREN, RPAREN;
//Reserved Words
terminal CSXToken               rw_BOOL, rw_BREAK, rw_CHAR, rw_CLASS, rw_CONST, rw_CONTINUE, rw_ENDIF, rw_ELSE, rw_FALSE, rw_IF, rw_INT, rw_FLOAT, rw_PRINT, rw_READ, rw_RETURN, rw_TRUE, rw_VOID, rw_WHILE;
//Unused Reserved Words
//terminal CSXToken               rw_FLOAT;
//Miscellaneous Symbols
terminal CSXToken               COLON, COMMA, SEMI;
//Error
//terminal CSXToken               error;
//End of file
//terminal CSXToken               EOF;
//Character Literal
terminal CSXCharLitToken        CHARLIT;
//Identifier
terminal CSXIdentifierToken     IDENTIFIER;
//Integer Literal
terminal CSXIntLitToken         INTLIT;
//Float Literal
terminal CSXFloatLitToken       FLOATLIT;
//String Literal
terminal CSXStringLitToken      STRLIT;

/* Non terminals */
non terminal classNode          Program;
non terminal memberDeclsNode    Memberdecls;
non terminal fieldDeclsNode     Fielddecls;
non terminal methodDeclsNode    Methoddecls;
non terminal optionalSemiNode   OptionalSemi;
non terminal methodDeclNode     Methoddecl;
non terminal argDeclsNode       Argdecls;
non terminal argDeclNode        Argdecl;
non terminal fieldDeclNode      Fielddecl;
non terminal stmtsNode          Stmts;
non terminal stmtNode           Stmt;
non terminal typeNode           Type;
non terminal argsNode           Args;
non terminal readListNode       Readlist;
non terminal printListNode      Printlist;
non terminal exprNode           Expr;
non terminal termNode           Term;
non terminal factorNode         Factor;
non terminal priNode            Pri;
non terminal unaryOpNode        Unary;
non terminal exprNode           Unit;
non terminal nameNode           Name;

/* Precedences/Associativity */
precedence left         CAND, COR, NOT;
precedence nonassoc     EQ, NOTEQ, GEQ, GT, LEQ, LT;
precedence left         PLUS, MINUS;
precedence left         TIMES, SLASH;
precedence right        NOT;
//Needed to make Unary highest precedence???
//precedence right        NOT, RPAREN;

/* The grammar */
start with Program;

//Program  →  class id { Memberdecls }
Program         ::= rw_CLASS:cl IDENTIFIER:id LBRACE Memberdecls:members RBRACE
                    {: RESULT= new classNode(id,members,cl.linenum,cl.colnum); :}
                ;
//Memberdecls  →  Fielddecl Memberdecls
//             |  Methoddecls
Memberdecls     ::= Fielddecl:field Memberdecls:members
                    //TODO{: RESULT= new memberDeclsNode(field,members,field.linenum,field.colnum); :}
                |   Methoddecls:methods
                    //TODO{: RESULT= new methodDeclsNode(); :}
                ;
//Fielddecls →  Fielddecl Fielddecls
//           |  λ
Fielddecls      ::= Fielddecl:field Fielddecls:fields
                    {: RESULT= new fieldDeclsNode(field,fields,field.linenum,field.colnum); :}
                |
                    {: RESULT= new nullFieldDeclsNode(); :}
                ;
//Methoddecls  →  Methoddecl Methoddecls
//             |  λ
Methoddecls     ::= Methoddecl:method Methoddecls:methods
                    {: RESULT= new methodDeclsNode(method,methods,method.linenum,method.colnum); :}
                |
                    {: RESULT= new nullMethodDeclsNode(); :}
                ;
//OptionalSemi  →  ;
//              |  λ
OptionalSemi    ::= SEMI:semi
                    {:  :}
                |
                    {:  :}
                ;
//Methoddecl →  void id ( ) { Fielddecls Stmts } OptionalSemi
//           |  void id ( Argdecls ) { Fielddecls Stmts } OptionalSemi
//           |  Type id ( ) { Fielddecls Stmts } OptionalSemi
//           |  Type id ( Argdecls ){ Fielddecls Stmts } OptionalSemi
Methoddecl      ::= rw_VOID:type IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:fields Stmts:stmts RBRACE OptionalSemi
                    {: RESULT= new methodDeclNode(id,null,null,fields,stmts,type.linenum,type.colnum); :}
                |   rw_VOID:type IDENTIFIER:id LPAREN Argdecls:args RPAREN LBRACE Fielddecls:fields Stmts:stmts RBRACE OptionalSemi
                    {: RESULT= new methodDeclNode(id,args,null,fields,stmts,type.linenum,type.colnum); :}
                |   Type:type IDENTIFIER:id LPAREN RPAREN LBRACE Fielddecls:fields Stmts:stmts RBRACE OptionalSemi
                    {: RESULT= new methodDeclNode(id,null,type,fields,stmts,type.linenum,type.colnum); :}
                |   Type:type IDENTIFIER:id LPAREN Argdecls:args RPAREN LBRACE Fielddecls:fields Stmts:stmts RBRACE OptionalSemi
                    {: RESULT= new methodDeclNode(id,args,type,fields,stmts,type.linenum,type.colnum); :}
                ;
//Argdecls  →  Argdecl , Argdecls
//          |  Argdecl
Argdecls        ::= Argdecl:argdec COMMA Argdecls:argdecs
                    {: RESULT= new argDeclsNode(argdec,argdecs,argdec.linenum,argdec.colnum); :}
                |   Argdecl:argdec
                    {: RESULT= argdec; :}
                ;
//Argdecl  →  Type id
//         |  Type id [ ]
Argdecl         ::= Type:type IDENTIFIER:id
                    {: RESULT= new valArgDeclNode(id,type,type.linenum,type.colnum); :}
                |   Type:type IDENTIFIER:id LBRACKET RBRACKET
                    {: RESULT= new arrayArgDeclNode(type,id,type.linenum,type.colnum); :}
                ;
//Fielddecl  →  Type id ;
//           |  Type id = Expr ;
//           |  Type id [ intlit ] ;
//           |  const id = Expr ;
Fielddecl       ::= Type:type IDENTIFIER:id SEMI
                    {: RESULT= new varDeclNode(id,type,null,type.linenum,type.colnum); :}
                |   Type:type IDENTIFIER:id ASG Expr:expr SEMI
                    {: RESULT= new varDeclNode(id,type,expr,type.linenum,type.colnum); :}
                |   Type:type IDENTIFIER:id LBRACKET INTLIT:loc RBRACKET SEMI
                    {: RESULT= new arrayDeclNode(id,type,loc,type.linenum,type.colnum); :}
                |   rw_CONST:type IDENTIFIER:id ASG Expr:expr SEMI
                    {: RESULT= new constDeclNode(id,expr,type.linenum,type.colnum); :}
                ;
//Stmts  →  Stmt Stmts
//       |  Stmt
Stmts           ::= Stmt:stmt Stmts:stmts
                    {: RESULT= new stmtsNode(stmt,stmts,stmt.linenum,stmt.colnum); :}
                |   Stmt:stmt
                    {: RESULT= stmt; :}
                ;
//Stmt  →  if ( Expr ) Stmt
//      |  if ( Expr ) Stmt else Stmt
//      |  while ( Expr ) Stmt
//      |  id : while ( Expr ) Stmt
//      |  Name = Expr ;
//      |  read ( Readlist ) ;
//      |  print ( Printlist ) ;
//      |  id ( ) ;
//      |  id ( Args ) ;
//      |  return ;
//      |  return Expr ;
//      |  break id ;
//      |  continue id ;
//      |  { Fielddecls Stmts } OptionalSemi
Stmt            ::= rw_IF:i LPAREN Expr:expr RPAREN Stmt:stmt rw_ENDIF
                    {: RESULT= new ifThenNode(expr,stmt,null,i.linenum,i.colnum); :}
                |   rw_IF:i LPAREN Expr:expr RPAREN Stmt:stmttrue rw_ELSE Stmt:stmtfalse rw_ENDIF
                    {: RESULT= new ifThenNode(expr,stmttrue,stmtfalse,i.linenum,i.colnum); :}
                |   rw_WHILE:whil LPAREN Expr:expr RPAREN Stmt:stmt
                    {: RESULT= new whileNode(null,expr,stmt,whil.linenum,whil.colnum); :}
                |   IDENTIFIER:id COLON rw_WHILE LPAREN Expr:expr RPAREN Stmt:stmt
                    {: RESULT= new whileNode(id,expr,stmt,whil.linenum,whil.colnum); :}
                |   Name:name ASG Expr:expr SEMI
                    {: RESULT= new asgNode(name,expr,name.linenum,name.colnum); :}
                |   rw_READ:read LPAREN Readlist:list RPAREN SEMI
                    {: RESULT= new stmtNode(read.linenum,read.colnum); :}
                |   rw_PRINT:print LPAREN Printlist:list RPAREN SEMI
                    {: RESULT= new stmtNode(print.linenum,print.colnum); :}
                |   IDENTIFIER:id LPAREN RPAREN SEMI
                    {: RESULT= new callNode(id,null,id.linenum,id.colnum); :}
                |   IDENTIFIER:id LPAREN Args:args RPAREN SEMI
                    {: RESULT= new callNode(id,args,id.linenum,id.colnum); :}
                |   rw_RETURN:ret SEMI
                    {: RESULT= new returnNode(ret,null,ret.linenum,ret.colnum); :}
                |   rw_RETURN:ret Expr:expr SEMI
                    {: RESULT= new returnNode(ret,expr,ret.linenum,ret.colnum); :}
                |   rw_BREAK:br IDENTIFIER:id SEMI
                    {: RESULT= new breakNode(id,br.linenum,br.colnum); :}
                |   rw_CONTINUE:cont IDENTIFIER:id SEMI
                    {: RESULT= new continueNode(id,cont.linenum,cont.colnum); :}
                |   LBRACE:brace Fielddecls:fields Stmts:stmts RBRACE OptionalSemi
                    {: RESULT= new stmtNode(brace.linenum,brace.colnum); :}
                ;
//Type  →  int
//      |  char
//      |  bool
//      |  float
Type            ::= rw_INT:type
                    {: RESULT= new intTypeNode(type.linenum,type.colnum); :}
                |   rw_CHAR:type
                    {: RESULT= new charTypeNode(type.linenum,type.colnum); :}
                |   rw_BOOL:type
                    {: RESULT= new boolTypeNode(type.linenum,type.colnum); :}
                |   rw_FLOAT:type
                    {: RESULT= type; :}
                ;
//Args  →  Expr , Args
//      |  Expr
Args            ::= Expr:expr COMMA Args:args
                    {: RESULT= new argDeclsNode(expr,args,expr.linenum,expr.colnum); :}
                |   Expr:expr
                    {: RESULT=expr; :}
                ;
//Readlist  →  Name , Readlist
//          |  Name
Readlist        ::= Name:name COMMA Readlist:list
                    {: RESULT= new readNode(name,list,name.linenum,name.colnum); :}
                |   Name:name
                    {: RESULT= name; :}
                ;
//Printlist  →  Expr , Printlist
//           |  Expr
Printlist       ::= Expr:expr COMMA Printlist:list
                    {: RESULT= new printNode(expr,list,expr.linenum,expr.colnum); :}
                |   Expr:expr
                    {: RESULT= expr; :}
                ;
//Expr  →  Expr || Term
//      |  Expr && Term
//      |  Term
Expr            ::= Expr:expr COR:op Term:term
                    {: RESULT= new binaryOpNode(expr,op,term,expr.linenum,expr.colnum); :}
                |   Expr:expr CAND:op Term:term
                    {: RESULT= new binaryOpNode(expr,op,term,expr.linenum,expr.colnum); :}
                |   Term:term
                    {: RESULT= term; :}
                ;
//Term  →  Factor < Factor
//      |  Factor > Factor
//      |  Factor <= Factor
//      |  Factor >= Factor
//      |  Factor == Factor
//      |  Factor != Factor
//      |  Factor
Term            ::= Factor:left LT:op Factor:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Factor:left GT:op Factor:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Factor:left LEQ:op Factor:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Factor:left GEQ:op Factor:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Factor:left EQ:op Factor:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Factor:left NOTEQ:op Factor:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Factor:left
                    {: RESULT= left; :}
                ;
//Factor  →  Factor + Pri
//        |  Factor - Pri
//        |  Pri
Factor          ::= Factor:left PLUS:op Pri:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Factor:left MINUS:op Pri:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Pri:left
                    {: RESULT= left; :}
                ;
//Pri →  Pri * Unary
//    |  Pri / Unary
//    |  Unary
Pri             ::= Pri:left TIMES:op Unary:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Pri:left SLASH:op Unary:right
                    {: RESULT= new binaryOpNode(left,op,right,left.linenum,left.colnum); :}
                |   Unary:left
                    {: RESULT= left; :}
                ;
//Unary  →  ! Unary
//       |  ( Type ) Unary
//       |  Unit
Unary           ::= NOT:op Unary:unary
                    {: RESULT= new unaryOpNode(op,unary,op.linenum,op.colnum); :}
                |   LPAREN:paren Type:type RPAREN Unary:unary
                    {: RESULT= new castNode(type,unary,paren.linenum,paren.colnum); :}
                |   Unit:unit
                    {: RESULT= unit; :}
                ;
//Unit  →  Name
//      |  id ( )
//      |  id ( Args )
//      |  intlit
//      |  charlit
//      |  floatlit
//      |  strlit
//      |  true
//      |  false
//      |  ( Expr )
Unit            ::= Name:name
                    {: RESULT= name; :}
                |   IDENTIFIER:id LPAREN RPAREN
                    {: RESULT= new fctCallNode(
                        new identNode(id.identifierText,id.linenum,id.colnum),
                        argsNode.NULL,
                        id.linenum,
                        id.colnum); :}
                |   IDENTIFIER:id LPAREN Args:args RPAREN
                    {: RESULT= new fctCallNode(
                        new identNode(id.identifierText,id.linenum,id.colnum),
                        args,
                        id.linenum,
                        id.colnum); :}
                |   INTLIT:i
                    {: RESULT= new intLitNode(i.intValue,i.linenum,i.colnum); :}
                |   CHARLIT:c
                    {: RESULT= new charLitNode(c.charValue,c.linenum,c.colnum); :}
                |   FLOATLIT:f
                    {: RESULT= new floatLitNode(f.floatValue,f.linenum,f.colnum); :}
                |   STRLIT:str
                    {: RESULT= new strLitNode(str.stringValue,str.linenum,str.colnum); :}
                |   rw_TRUE:t
                    {: RESULT= new trueNode(t.linenum,t.colnum); :}
                |   rw_FALSE:f
                    {: RESULT= new falseNode(f.linenum,f.colnum); :}
                |   LPAREN:paren Expr:expr RPAREN
                    //From page 4 of CUP User's Manual
                    {: RESULT= expr; :}
                ;
//name  →  id
//      |  id [ Expr ]
Name            ::= IDENTIFIER:id
                    {: RESULT= new nameNode(
                        new identNode(id.identifierText,id.linenum,id.colnum),
                        exprNode.NULL,
                        id.linenum,
                        id.colnum); :}
                |   IDENTIFIER:id LBRACKET Expr:expr RBRACKET
                    {: RESULT= new nameNode(
                        new identNode(id.identifierText,id.linenum,id.colnum),
                        expr,
                        id.linenum,
                        id.colnum); :}
                ;
